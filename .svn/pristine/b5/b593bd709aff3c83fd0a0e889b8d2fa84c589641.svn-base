/* -------------------------------------------------------------------------- *
 *                           MMB (MacroMoleculeBuilder)                       *
 * -------------------------------------------------------------------------- *
 *                                                                            *
 * Copyright (c) 2011-12 by the Author.                                       *
 * Author: Samuel Flores                                                      *
 *                                                                            *
 * See RNABuilder.cpp for the copyright and usage agreement.                  *
 * -------------------------------------------------------------------------- */

#include "Utils.h"
#include "BiopolymerClass.h"
#include "MobilizerContainer.h"
#include "SimTKmolmodel.h"
#include "ReferenceNeighborList.h"


void MobilizerContainer::clear(){
    residueStretchVector.clear();
    mobilizerWithinVector.clear();
    mobilizerInterfaceContainer.clear();
};
bool MobilizerContainer::isEmpty() {
    if ((residueStretchVector.size() >0) ||
        (mobilizerWithinVector.size() >0) ||
        (mobilizerInterfaceContainer.numInterfaces() >0) )
        {return false;}
    else {return true;}
}



void MobilizerContainer::validateMobilizerStretch(MobilizerStretch & myMobilizerStretch, BiopolymerClassContainer & myBiopolymerClassContainer){
    
    if (!(myBiopolymerClassContainer.hasChainID(myMobilizerStretch.getChain()))){
	ErrorManager::instance <<__FILE__<<":"<<__LINE__<<" Couldn't find chain "<<myMobilizerStretch.getChain()<<endl; ErrorManager::instance.treatError();
    }
    if ( myBiopolymerClassContainer.updBiopolymerClass(myMobilizerStretch.getChain()).difference(myMobilizerStretch.getEndResidue() , myMobilizerStretch.getStartResidue()) < 0) {
    }
    myBiopolymerClassContainer.updBiopolymerClass(myMobilizerStretch.getChain()).validateResidueID(myMobilizerStretch.getEndResidue());
    if ((myMobilizerStretch.getStartResidue() < myBiopolymerClassContainer.updBiopolymerClass(myMobilizerStretch.getChain()).getFirstResidueID()) ) {
	ErrorManager::instance <<__FILE__<<":"<<__LINE__<<" The start residue (currently "<<myMobilizerStretch.getStartResidue().outString()<<") is lesser than the first residue number of the chain."<<endl; ErrorManager::instance.treatError();
    }
    validateResidueStretch(myMobilizerStretch,myBiopolymerClassContainer); // This method from the parent class has basic checks, e.g. making sure EndResidue > StartResidue.
};

void MobilizerContainer::validateMobilizerStretch(int  mobilizerStretchIndex, BiopolymerClassContainer & myBiopolymerClassContainer){
    MobilizerStretch myMobilizerStretch = getResidueStretch(mobilizerStretchIndex);
    validateMobilizerStretch(myMobilizerStretch,myBiopolymerClassContainer);
};

void MobilizerContainer::printMobilizerStretch(int mobilizerStretchIndex){
        cout<<__FILE__<<":"<<__LINE__<<" Mobilizer stretch "<<mobilizerStretchIndex<<" BondMobility = "<<getResidueStretch(mobilizerStretchIndex ).getBondMobilityString()<<endl;
        cout<<__FILE__<<":"<<__LINE__<<" chain= "<<getResidueStretch(mobilizerStretchIndex ).getChain()  <<" from residue "<<getResidueStretch(mobilizerStretchIndex ).getStartResidue().outString()<<" to "<<getResidueStretch(mobilizerStretchIndex ).getEndResidue().outString()<<endl;
};

void MobilizerContainer::printMobilizerStretches(){
    for (int i = 0; i < getNumResidueStretches(); i++) {
        printMobilizerStretch(i);
    }
};
    




void MobilizerContainer::addMobilizerStretchToVector(MobilizerStretch myMobilizerStretch, BiopolymerClassContainer & myBiopolymerClassContainer) {
    validateMobilizerStretch(myMobilizerStretch, myBiopolymerClassContainer); 
    addResidueStretchToVector(myMobilizerStretch );
    //printMobilizerStretch(getNumResidueStretches()-1);
};

void MobilizerContainer::addMobilizerStretchToVector(String myChain, ResidueID myStartResidue, ResidueID myEndResidue, String bondMobilityString, BiopolymerClassContainer & myBiopolymerClassContainer) {
    MobilizerStretch myMobilizerStretch;
    myMobilizerStretch.setChain ( myChain);
    myMobilizerStretch.setStartResidue ( myStartResidue);
    myMobilizerStretch.setEndResidue ( myEndResidue);
    myMobilizerStretch.setBondMobility(bondMobilityString );
    addMobilizerStretchToVector(myMobilizerStretch,myBiopolymerClassContainer);
};


void MobilizerContainer::addMobilizerStretchToVector(String myChain, String bondMobilityString, BiopolymerClassContainer & myBiopolymerClassContainer) {
    
    addMobilizerStretchToVector(myChain, myBiopolymerClassContainer.updBiopolymerClass(myChain).getFirstResidueID(), myBiopolymerClassContainer.updBiopolymerClass(myChain).getLastResidueID(),bondMobilityString, myBiopolymerClassContainer);
};

void MobilizerContainer::addMobilizerStretchToVector(MobilizerStretch residueStretch, String  bondMobilityString , BiopolymerClassContainer & myBiopolymerClassContainer) {
        addMobilizerStretchToVector(MobilizerStretch(residueStretch, bondMobilityString) ,  myBiopolymerClassContainer);  
};

void MobilizerContainer::updateMobilizerStretch(int id, String myChain, 
                                                ResidueID myStartResidue, 
                                                ResidueID myEndResidue, 
                                                String bondMobilityString, 
                                                BiopolymerClassContainer & myBiopolymerClassContainer){
    MobilizerStretch & ms = residueStretchVector[id];
    ms.setChain(myChain);
    ms.setStartResidue(myStartResidue);
    ms.setEndResidue(myEndResidue);
    ms.setBondMobility(bondMobilityString);
    validateMobilizerStretch(ms, myBiopolymerClassContainer);
}

void MobilizerContainer::deleteMobilizerStretch(int id){
    residueStretchVector.erase(residueStretchVector.begin()+id);
}


void MobilizerContainer::addMobilizerStretchesToVector(vector <MobilizerStretch> residueStretchVector, String  bondMobilityString , BiopolymerClassContainer & myBiopolymerClassContainer) {
    for (int i = 0; i < residueStretchVector.size()  ; i++) {
        cout<<__FILE__<<":"<<__LINE__<<" Inside addMobilizerStretchesToVector, adding stretch "<<i<<endl;
        cout<<__FILE__<<":"<<__LINE__<<" index "<<i<<" chain "<<residueStretchVector[i].getChain()<<", residue = "<<residueStretchVector[i].getStartResidue().outString()<<" to "<<residueStretchVector[i].getEndResidue().outString()<<endl;
        addMobilizerStretchToVector(residueStretchVector[i], bondMobilityString,  myBiopolymerClassContainer);
    }
};

// loop through all specified Interfaces, add interface residues to residueStretchVector

void MobilizerContainer::addMobilizerStretchesToVector(BiopolymerClassContainer  & myBiopolymerClassContainer) {
	for (int i = 0; i < mobilizerInterfaceContainer.numInterfaces(); i++) {
                // create temporary ResidueStretchContainer which will figure out which residues are in the interface.  We then  add these to residueStretchVector.
		ResidueStretchContainer <MobilizerStretch> tempResidueStretchContainer;
		MobilizerInterface tempMobilizerInterface = mobilizerInterfaceContainer.getMobilizerInterface(i);
		tempResidueStretchContainer.addAllMutualChainResidues(tempMobilizerInterface.Depth, tempMobilizerInterface.Chains, tempMobilizerInterface.PartnerChains, myBiopolymerClassContainer);
		//tempResidueStretchContainer.addAllMutualChainResidues(tempMobilizerInterface.Depth, tempMobilizerInterface.Chains,myBiopolymerClassContainer);
                cout<<__FILE__<<":"<<__LINE__<<endl;
		addMobilizerStretchesToVector(tempResidueStretchContainer.getResidueStretchVector(), tempMobilizerInterface.MobilizerString, myBiopolymerClassContainer);   
                cout<<__FILE__<<":"<<__LINE__<<endl;
	}
};

// Call this from Repel.cpp. New way, using molmodel's neighborlisting:
/*void MobilizerContainer::addMobilizerStretchesToVector(BiopolymerClassContainer  & myBiopolymerClassContainer, CompoundSystem & compoundSystem, State & state) {


	for (int i = 0; i < mobilizerInterfaceContainer.numInterfaces(); i++) {
                // create temporary ResidueStretchContainer which will figure out which residues are in the interface.  We then  add these to residueStretchVector.
		ResidueStretchContainer <ResidueStretch> tempResidueStretchContainer;
		MobilizerInterface tempMobilizerInterface = mobilizerInterfaceContainer.getMobilizerInterface(i); 
                // New way, using molmodel's neighborlisting method:
		tempResidueStretchContainer.addAllMutualChainResidues(tempMobilizerInterface.Depth, tempMobilizerInterface.Chain,state, myBiopolymerClassContainer);
		addMobilizerStretchesToVector(tempResidueStretchContainer.getResidueStretchVector(), tempMobilizerInterface.MobilizerString, myBiopolymerClassContainer);   
	}
};*/


void MobilizerContainer::addMobilizerStretchesToVector(vector <MobilizerStretch> residueStretchVector,  BiopolymerClassContainer & myBiopolymerClassContainer) {
    for (int i = 0; i < (int)residueStretchVector.size(); i++) {
        addMobilizerStretchToVector(residueStretchVector[i],  myBiopolymerClassContainer);
    }
};

/*void MobilizerContainer::addMobilizerStretchesToVector(vector <MobilizerStretch> residueStretchVector,  BiopolymerClassContainer & myBiopolymerClassContainer) {
    for (int i = 0; i < (int)residueStretchVector.size(); i++) {
        addMobilizerStretchToVector(residueStretchVector[i],  state, compoundSystem);
    }
};*/


String MobilizerContainer::getChain(int mobilizerStretchIndex){
    return getResidueStretch(mobilizerStretchIndex).getChain();
};
ResidueID MobilizerContainer::getStartResidue(int mobilizerStretchIndex){
    return getResidueStretch(mobilizerStretchIndex).getStartResidue();
};

ResidueID MobilizerContainer::getEndResidue(int mobilizerStretchIndex){
    return getResidueStretch(mobilizerStretchIndex).getEndResidue();
};


void MobilizerContainer::setBiopolymerBondMobility (BiopolymerClassContainer & myBiopolymerClassContainer) {
    for (int q=0;q<getNumResidueStretches();q++)
    {               
        //BondMobility myBondMobility = getBondMobility(q);
        BiopolymerClass & myBiopolymerClass ( myBiopolymerClassContainer.updBiopolymerClass((residueStretchVector[q]).getChain()));
        BiopolymerType::BiopolymerTypeEnum btype = myBiopolymerClassContainer.updBiopolymerClass(getChain(q)).biopolymerType; 

        if (btype == BiopolymerType::RNA){
            (static_cast<RNA&>( myBiopolymerClass.myBiopolymer)).setRNABondMobility(getResidueStretch(q).getBondMobility(),
            SimTK::ResidueInfo::Index (myBiopolymerClass.getResidueIndex(getStartResidue(q) )),
            SimTK::ResidueInfo::Index ( myBiopolymerClass.getResidueIndex( getEndResidue(q))));                   

        } else if (btype == BiopolymerType::DNA){
            (static_cast<DNA&>( myBiopolymerClass.myBiopolymer)).setDNABondMobility(getResidueStretch(q).getBondMobility(),
            SimTK::ResidueInfo::Index (myBiopolymerClass.getResidueIndex  ( getStartResidue(q) )),
            SimTK::ResidueInfo::Index (myBiopolymerClass.getResidueIndex   ( getEndResidue(q) )));

        } else if (btype == BiopolymerType::Protein) {
            myBiopolymerClass.setProteinBondMobility(
                getResidueStretch(q).getBondMobility(),
                getStartResidue(q),
                getEndResidue(q)
            );
        } 
        else {
            ErrorManager::instance << __FUNCTION__ << ": biopolymerType " << btype << " unknown" << endl;
            ErrorManager::instance.treatError();
        }
    }
};


void MobilizerContainer::createMobilizersWithin ( BiopolymerClassContainer & myBiopolymerClassContainer){//, State & state ){
    for (int h = 0; h < (int)mobilizerWithinVector.size(); h++){
        BiopolymerClass  primaryBiopolymerClass = myBiopolymerClassContainer.updBiopolymerClass(mobilizerWithinVector[h].Chain);
        for (int i = 0; i < myBiopolymerClassContainer.getNumBiopolymers(); i++) {
            BiopolymerClass  partnerBiopolymerClass = myBiopolymerClassContainer.updBiopolymerClass(i);
            ResidueID j(partnerBiopolymerClass.getFirstResidueID()); 
            for ( j = partnerBiopolymerClass.getFirstResidueID(); j <= partnerBiopolymerClass.getLastResidueID();partnerBiopolymerClass.incrementResidueID( j) ) {
                double myDistance = (double)(

                    partnerBiopolymerClass.calcDefaultAtomLocationInGroundFrame  ( j, partnerBiopolymerClass.getRepresentativeAtomName())
                    - primaryBiopolymerClass.calcDefaultAtomLocationInGroundFrame(mobilizerWithinVector[h].Residue , primaryBiopolymerClass.getRepresentativeAtomName())
                    ).norm();
                    //partnerBiopolymerClass.calcAtomLocationInGroundFrame  (state, j, partnerBiopolymerClass.getRepresentativeAtomName())
                    //- primaryBiopolymerClass.calcAtomLocationInGroundFrame(state,mobilizerWithinVector[h].Residue , primaryBiopolymerClass.getRepresentativeAtomName())
                    //).norm();
                if (myDistance <= (mobilizerWithinVector[h].Radius)){ // used to div by 10 to convert Å to nm .. now just using nm directly.
                    MobilizerStretch myMobilizer;
                    myMobilizer.setChain ( partnerBiopolymerClass.getChainID());
                    myMobilizer.setStartResidue (j);
                    myMobilizer.setEndResidue (j);
                    myMobilizer.setBondMobility(mobilizerWithinVector[h].BondMobilityString );
                    addMobilizerStretchToVector(myMobilizer, myBiopolymerClassContainer);
                } // of if
                if (j == partnerBiopolymerClass.getLastResidueID() ) break;
            } // of for j
        } // of for i
    } // of for h
}; // of method

void MobilizerContainer::pushMobilizerWithin ( MobilizerWithin mobilizerWithin, BiopolymerClassContainer & myBiopolymerClassContainer){
    validateMobilizerWithin(mobilizerWithin,myBiopolymerClassContainer);
    mobilizerWithinVector.push_back(mobilizerWithin);
};


void MobilizerContainer::validateMobilizerWithin(MobilizerWithin mobilizerWithin ,  BiopolymerClassContainer & myBiopolymerClassContainer){
        myBiopolymerClassContainer.updBiopolymerClass(mobilizerWithin.Chain).validateResidueID(mobilizerWithin.Residue); // not really necessary; this was validated in ParameterReader.cpp

};

int MobilizerContainer::numMobilizerWithin() {
    return mobilizerWithinVector.size() ;
};

void MobilizerContainer::addPhiPsiMobility(String chain, ResidueID startResidue, ResidueID endResidue, String bondMobilityString , BiopolymerClassContainer& myBiopolymerClassContainer ) {
    SingleBondMobility mySingleBondMobility;
    mySingleBondMobility.residue1 = startResidue;	
    mySingleBondMobility.residue2 = startResidue;	
    myBiopolymerClassContainer.validateChainID(chain);
    myBiopolymerClassContainer.updBiopolymerClass(chain).validateResidueID(startResidue);   
    myBiopolymerClassContainer.updBiopolymerClass(chain).validateResidueID(endResidue);   
    mySingleBondMobility.chain1 = chain;
    mySingleBondMobility.chain2 = chain;
    mySingleBondMobility.mobility = bondMobilityString;
    while(  mySingleBondMobility.residue1 <=  endResidue) {
                 // First do the N-CA bond:
                mySingleBondMobility.atom1    = String("N"); 
                mySingleBondMobility.atom2    = String("CA"); 
                // atomPathString used to self-validate.  However it no longer does that, because occasionally we want to create paths that will be validated only later.  In any event, we need to validate explicitly here:
                Compound::AtomPathName myAtomPathName1 = myBiopolymerClassContainer.updBiopolymerClass(mySingleBondMobility.chain1).atomPathString(mySingleBondMobility.residue1, mySingleBondMobility.atom1);
                myBiopolymerClassContainer.updBiopolymerClass(mySingleBondMobility.chain1).validateAtomPathName(myAtomPathName1);
                Compound::AtomPathName myAtomPathName2 = myBiopolymerClassContainer.updBiopolymerClass(mySingleBondMobility.chain2).atomPathString(mySingleBondMobility.residue2, mySingleBondMobility.atom2);
                myBiopolymerClassContainer.updBiopolymerClass(mySingleBondMobility.chain2).validateAtomPathName(myAtomPathName2);
                singleBondMobilityVector.push_back(mySingleBondMobility);

                // Now do the C-CA bond:
                // this might become necessary:
                SingleBondMobility mySingleBondMobility2 = mySingleBondMobility ;
                mySingleBondMobility2.atom1    = String("C"); 
                myAtomPathName1 = myBiopolymerClassContainer.updBiopolymerClass(mySingleBondMobility2.chain1).atomPathString(mySingleBondMobility2.residue1, mySingleBondMobility2.atom1);
                myBiopolymerClassContainer.updBiopolymerClass(mySingleBondMobility2.chain1).validateAtomPathName(myAtomPathName1);
                singleBondMobilityVector.push_back(mySingleBondMobility2);

                if (mySingleBondMobility2.residue1 < endResidue){ // We have to be careful not to increment myResidueID past the end of the chain
                        mySingleBondMobility.residue1 = myBiopolymerClassContainer.updBiopolymerClass(mySingleBondMobility.chain1).incrementResidueID(mySingleBondMobility.residue1);
                        mySingleBondMobility.residue2 = myBiopolymerClassContainer.updBiopolymerClass(mySingleBondMobility.chain2).incrementResidueID(mySingleBondMobility.residue2); 
			if (!(mySingleBondMobility.residue1 == mySingleBondMobility.residue2)) {
			    ErrorManager::instance <<__FILE__<<":"<<__LINE__<<" Error!  residue1 and  residue2 are not equal ."<<endl; ErrorManager::instance.treatError();}
		}
                else if (mySingleBondMobility.residue1  == endResidue) {
                        break;
                }
    }

}

void MobilizerContainer::addPhiPsiMobility(String bondMobilityString , BiopolymerClassContainer& myBiopolymerClassContainer ) {
	
    for (int i = 0; i < myBiopolymerClassContainer.getNumBiopolymers(); i++) {
	BiopolymerClass       myBiopolymerClass = myBiopolymerClassContainer.updBiopolymerClass(i);
        if (myBiopolymerClass.getBiopolymerType() == BiopolymerType::Protein){
	    //String chain = myBiopolymerClass.getChainID();
            addPhiPsiMobility(myBiopolymerClass.getChainID() , myBiopolymerClass.getFirstResidueID(), myBiopolymerClass.getLastResidueID(), bondMobilityString, myBiopolymerClassContainer);
	    
        }
    }
};

void MobilizerContainer::deleteMobilizerWithin(int id){
    mobilizerWithinVector.erase(mobilizerWithinVector.begin()+id);
}

void MobilizerContainer::updateMobilizerWithin(int id, String myChain, ResidueID myRes, double myRadius, String bondMobilityString, BiopolymerClassContainer & myBiopolymerClassContainer){
    MobilizerWithin & mw = mobilizerWithinVector[id];
    mw.Chain = myChain;
    mw.Residue = myRes;
    mw.Radius = myRadius;
    mw.BondMobilityString = bondMobilityString;
    validateMobilizerWithin(mw, myBiopolymerClassContainer);
}
